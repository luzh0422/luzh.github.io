---
title: 鱼眼相机贴图到原模型上
date: 2021-02-28 12:57:51
tags: webgl | opengl
mathjax: true
---

## 鱼眼相机贴图到原模型上的意义

鱼眼相机拍摄的是真实场景中的内容，而有的时候我们需要在真实场景中再添加一些虚拟场景内容，这个时候就需要通过3D技术渲染一些场景模型，并将鱼眼相机拍摄的图像贴到模型上以达到效果，这样就可以达到一种虚实结合的效果。

<!--more-->

## 鱼眼相机

研究表明鱼眼相机成像时遵循的模型可以近似为单位球面模型。可以将鱼眼相机的成像过程分解成两步：

    1. 三维空间点线性地投影到一个球面上，它是一个虚拟的单位球面，它的球心与相机坐标系的原点重合；
    2. 单位球面上的点投影到图像平面上；

因此，再把鱼眼相机图像贴到原始模型上时，也是遵循这样的一个算法。

## 算法介绍

按照上述鱼眼相机的成像过程，我们可以将模型中的点也经过这个过程，然后在成像图像中进行采样，即可完成在鱼眼相机下的纹理贴图。

{% asset_img 视频融合-鱼眼纹理算法流程.jpg 400 视频融合-鱼眼纹理算法流程 %}

首先，我们需要将三维空间中的点线性地投影到一个单位球面上。

具体的转换过程有些类似[三维空间中直角坐标与球坐标的相互转换](https://www.cnblogs.com/hans_gis/archive/2012/11/21/2755126.html)。我们以相机为坐标原点构建整个坐标系，并以球坐标的形式记录三维空间中的每一个点的坐标。如下图所示。

{% asset_img 鱼眼贴图.png 400 鱼眼贴图 %}

具体流程如下：

* 首先我们知道三维世界中一个点的位置pos，相机的位置center，相机的朝向forward，相机的上轴up。
* 计算相机到三维世界中点的方向 dir = normalize(pos - center);
* 求forward与dir的夹角作为经度，float v = acos(dot(dir, forward))，这个位子的求解过程运用到了向量点乘的公式，$\vec{a}\cdot\vec{b} = |\vec{a}||\vec{b}|\cos\theta$，其中$\theta$是$\vec{a}$和$\vec{b}$的夹角；由于$\vec{a}$和$\vec{b}$都是单位向量，所以$\theta$ = $\arccos(\vec{a}\cdot\vec{b})$;
* 然后在求dir在up所在平面（改平面以forward为法线）的投影与up的夹角，根据一个向量和平面发现，求这个向量在这个平面的夹角公式为
    * 首先求向量在法线上的投影 $(\vec{dir}\cdot\vec{forward})\times\vec{forward}$
    * 其次dir减去上述的向量就是dir在平面上的投影，$\vec{dir} - (\vec{dir}\cdot\vec{forward})\times\vec{forward}$
    * 然后就可以求出up与平面上的投影向量的夹角作为纬度，float u = acos(dot(dirProj, up));

具体代码如下（我们本文的算法都是执行在webgl中的，所以代码形式以glsl呈现）：

```javascript
    "vec2 ComputeAngle(vec3 pos,vec3 center,vec3 forward,vec3 up) {",
      "vec3 dir = normalize(pos - center);", // 相机指向顶点的方向；
      "forward = normalize(forward);", // forward是y轴
      "up = normalize(up);",

      /**
       * dir在于forward垂直平面上的投影单位向量；
       */
      "vec3 projDir = normalize(dir - dot(dir, forward) * forward);",

      "float v = acos(dot(dir,forward)) * 180.0 / 3.141593;", // 经度；
      "float u = acos(dot(projDir,up)) * 180.0 / 3.141593;", // 纬度

      // 纬度值需要考虑360度夹角，所以有负值；
      "if(!(projDir.x == up.x && projDir.y == up.y && projDir.z == up.z)) {",
        /**
         * 由于cross依照的是右手坐标系，所有projDir与up的夹角大于180°的时候，cross得出的向量与forward相反；
         */
        "float rst = dot(normalize(cross(projDir,up)),forward);",
        "if(rst > 0.0) { u *= -1.0; }",
      "}",

      "return vec2(u,v);",
    "}",
```

上面就是将一个三维空间中的点映射到一个单位球上的全部过程，其次我们要求这个球上的点到成像平面的映射。

其实这非常简单，因为只要知道经度和纬度，球面上任意一个点在横切面上的投影都可以知道。

如图所示：

{% asset_img 横切面投影.png 400 横切面投影 %}

只需要找到球面上的点在横切面上的映射点，然后求这个点的坐标，并映射到[0, 1]即为投影坐标了。

具体代码如下：

```javascript
    "vec2 ComputeUV(vec2 circleAngle,float fieldAngle) {",
      "vec2 newVector = vec2(-1.0 * sin(-circleAngle.x / 180.0 * 3.14159),cos(-circleAngle.x / 180.0 * 3.14159));",
      "vec2 outputUV = newVector * 0.5 * (circleAngle.y / fieldAngle) + vec2(0.5,0.5);",
      // "vec2 output = vec2(newVector.x * 0.5 * (circleAngle.y / fieldAngle) + 0.5, newVector.y * 0.5 * (circleAngle.y / fieldAngle) + 0.5)",
      "return outputUV;",
    "}",
```

这样，我们就可以求出三维空间中任意一点映射到鱼眼相机成像图像中的uv坐标了。

## 参考

* [三维空间中直角坐标与球坐标的相互转换](https://www.cnblogs.com/hans_gis/archive/2012/11/21/2755126.html)
* [一个向量在一个平面上的投影](https://bbs.csdn.net/topics/280056188)
* [点积运算](https://zh.wikipedia.org/wiki/%E7%82%B9%E7%A7%AF)
* [鱼眼镜头模型](https://jiangren.work/2019/09/13/%E9%B1%BC%E7%9C%BC%E9%95%9C%E5%A4%B4%E6%A8%A1%E5%9E%8B/)
* [球体绘制](http://www.hiwebgl.com/?p=339)
* [3d数学之向量详解](https://www.jianshu.com/p/da7ab38e48ab)
* [反三家函数](https://zh.wikipedia.org/wiki/%E5%8F%8D%E4%B8%89%E8%A7%92%E5%87%BD%E6%95%B0)